{"version":3,"file":"sendJsonRpcPayload.js","sourceRoot":"","sources":["../../../src/web3-adapter/sendJsonRpcPayload.ts"],"names":[],"mappings":"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","sourcesContent":["import assertNever from \"assert-never\";\nimport {\n  FullConfig,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  Provider,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n} from \"../types\";\nimport { delay, promisify } from \"../util/promises\";\nimport { AlchemySendJsonRpcFunction } from \"./alchemySend\";\n\nconst ALCHEMY_DISALLOWED_METHODS: string[] = [\n  \"eth_accounts\",\n  \"eth_sendTransaction\",\n  \"eth_sign\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData\",\n  \"personal_sign\",\n];\n\nexport interface JsonRpcPayloadSender {\n  sendJsonRpcPayload: SendJsonRpcPayloadFunction;\n  setWriteProvider(writeProvider: Provider | null | undefined): void;\n}\n\nexport interface SendJsonRpcPayloadFunction {\n  (payload: JsonRpcRequest): Promise<JsonRpcResponse>;\n  (payload: SingleOrBatchRequest): Promise<SingleOrBatchResponse>;\n}\n\nexport function makeJsonRpcPayloadSender(\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  config: FullConfig,\n): JsonRpcPayloadSender {\n  let currentWriteProvider = config.writeProvider;\n\n  const sendJsonRpcPayload = (\n    payload: SingleOrBatchRequest,\n  ): Promise<SingleOrBatchResponse> => {\n    const disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendJsonRpcWithProvider(currentWriteProvider, payload);\n        } catch {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\n          `No provider available for method \"${disallowedMethod}\"`,\n        );\n      }\n      return sendJsonRpcWithProvider(currentWriteProvider, payload);\n    }\n  };\n\n  function setWriteProvider(writeProvider: Provider | null | undefined) {\n    currentWriteProvider = writeProvider ?? null;\n  }\n\n  return {\n    sendJsonRpcPayload: sendJsonRpcPayload as SendJsonRpcPayloadFunction,\n    setWriteProvider,\n  };\n}\n\nfunction sendJsonRpcWithProvider(\n  provider: Provider,\n  payload: SingleOrBatchRequest,\n): Promise<SingleOrBatchResponse> {\n  const anyProvider: any = provider;\n  const sendMethod = (\n    anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send\n  ).bind(anyProvider);\n  return promisify((callback) => sendMethod(payload, callback));\n}\n\nfunction getDisallowedMethod(\n  payload: SingleOrBatchRequest,\n): string | undefined {\n  const payloads = Array.isArray(payload) ? payload : [payload];\n  const disallowedRequest =\n    payloads.find((p) => ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0) ||\n    undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nasync function sendJsonRpcWithRetries(\n  payload: SingleOrBatchRequest,\n  alchemySendJsonRpc: AlchemySendJsonRpcFunction,\n  { maxRetries, retryInterval, retryJitter }: FullConfig,\n): Promise<SingleOrBatchResponse> {\n  for (let i = 0; i < maxRetries + 1; i++) {\n    const result = await alchemySendJsonRpc(payload);\n    switch (result.type) {\n      case \"jsonrpc\":\n        return result.response;\n      case \"rateLimit\":\n        break;\n      case \"networkError\": {\n        const { status, message } = result;\n        const statusString = status !== 0 ? `(${status}) ` : \"\";\n        throw new Error(`${statusString} ${message}`);\n      }\n      default:\n        return assertNever(result);\n    }\n    await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n  }\n  throw new Error(`Rate limited for ${maxRetries + 1} consecutive attempts.`);\n}\n"]}